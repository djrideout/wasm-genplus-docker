/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main/js/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./src/main/js/genplus.js":
/*!********************************!*\
  !*** ./src/main/js/genplus.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process, __dirname, module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar Module = function () {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n\n  return function (Module) {\n    Module = Module || {}; // Copyright 2010 The Emscripten Authors.  All rights reserved.\n    // Emscripten is available under two separate licenses, the MIT license and the\n    // University of Illinois/NCSA Open Source License.  Both these licenses can be\n    // found in the LICENSE file.\n    // The Module object: Our interface to the outside world. We import\n    // and export values on it. There are various ways Module can be used:\n    // 1. Not defined. We create it here\n    // 2. A function parameter, function(Module) { ..generated code.. }\n    // 3. pre-run appended it, var Module = {}; ..generated code..\n    // 4. External script tag defines var Module.\n    // We need to check if Module already exists (e.g. case 3 above).\n    // Substitution will be replaced with actual code on later stage of the build,\n    // this way Closure Compiler will not mangle it (e.g. case 4. above).\n    // Note that if you want to run closure, and also to use Module\n    // after the generated code, you will need to define   var Module = {};\n    // before the code. Then that object will be used in the code, and you\n    // can continue to use Module afterwards as well.\n\n    var Module = typeof Module !== 'undefined' ? Module : {}; // --pre-jses are emitted after the Module integration code, so that they can\n    // refer to Module (if they choose; they can also define Module)\n    // {{PRE_JSES}}\n    // Sometimes an existing Module object exists with properties\n    // meant to overwrite the default module functionality. Here\n    // we collect those properties and reapply _after_ we configure\n    // the current environment's defaults to avoid having to be so\n    // defensive during initialization.\n\n    var moduleOverrides = {};\n    var key;\n\n    for (key in Module) {\n      if (Module.hasOwnProperty(key)) {\n        moduleOverrides[key] = Module[key];\n      }\n    }\n\n    var arguments_ = [];\n    var thisProgram = './this.program';\n\n    var quit_ = function quit_(status, toThrow) {\n      throw toThrow;\n    }; // Determine the runtime environment we are in. You can customize this by\n    // setting the ENVIRONMENT setting at compile time (see settings.js).\n\n\n    var ENVIRONMENT_IS_WEB = false;\n    var ENVIRONMENT_IS_WORKER = false;\n    var ENVIRONMENT_IS_NODE = false;\n    var ENVIRONMENT_HAS_NODE = false;\n    var ENVIRONMENT_IS_SHELL = false;\n    ENVIRONMENT_IS_WEB = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object';\n    ENVIRONMENT_IS_WORKER = typeof importScripts === 'function'; // A web environment like Electron.js can have Node enabled, so we must\n    // distinguish between Node-enabled environments and Node environments per se.\n    // This will allow the former to do things like mount NODEFS.\n    // Extended check using process.versions fixes issue #8816.\n    // (Also makes redundant the original check that 'require' is a function.)\n\n    ENVIRONMENT_HAS_NODE = (typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === 'object' && _typeof(process.versions) === 'object' && typeof process.versions.node === 'string';\n    ENVIRONMENT_IS_NODE = ENVIRONMENT_HAS_NODE && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\n    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\n    if (Module['ENVIRONMENT']) {\n      throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');\n    } // `/` should be present at the end if `scriptDirectory` is not empty\n\n\n    var scriptDirectory = '';\n\n    function locateFile(path) {\n      if (Module['locateFile']) {\n        return Module['locateFile'](path, scriptDirectory);\n      }\n\n      return scriptDirectory + path;\n    } // Hooks that are implemented differently in different runtime environments.\n\n\n    var read_, readAsync, readBinary, setWindowTitle;\n\n    if (ENVIRONMENT_IS_NODE) {\n      scriptDirectory = __dirname + '/'; // Expose functionality in the same simple way that the shells work\n      // Note that we pollute the global namespace here, otherwise we break in node\n\n      var nodeFS;\n      var nodePath;\n\n      read_ = function shell_read(filename, binary) {\n        var ret;\n        if (!nodeFS) nodeFS = __webpack_require__(/*! fs */ \"fs\");\n        if (!nodePath) nodePath = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n        filename = nodePath['normalize'](filename);\n        ret = nodeFS['readFileSync'](filename);\n        return binary ? ret : ret.toString();\n      };\n\n      readBinary = function readBinary(filename) {\n        var ret = read_(filename, true);\n\n        if (!ret.buffer) {\n          ret = new Uint8Array(ret);\n        }\n\n        assert(ret.buffer);\n        return ret;\n      };\n\n      if (process['argv'].length > 1) {\n        thisProgram = process['argv'][1].replace(/\\\\/g, '/');\n      }\n\n      arguments_ = process['argv'].slice(2); // MODULARIZE will export the module in the proper place outside, we don't need to export here\n\n      process['on']('uncaughtException', function (ex) {\n        // suppress ExitStatus exceptions from showing an error\n        if (!(ex instanceof ExitStatus)) {\n          throw ex;\n        }\n      });\n      process['on']('unhandledRejection', abort);\n\n      quit_ = function quit_(status) {\n        process['exit'](status);\n      };\n\n      Module['inspect'] = function () {\n        return '[Emscripten Module object]';\n      };\n    } else if (ENVIRONMENT_IS_SHELL) {\n      if (typeof read != 'undefined') {\n        read_ = function shell_read(f) {\n          return read(f);\n        };\n      }\n\n      readBinary = function readBinary(f) {\n        var data;\n\n        if (typeof readbuffer === 'function') {\n          return new Uint8Array(readbuffer(f));\n        }\n\n        data = read(f, 'binary');\n        assert(_typeof(data) === 'object');\n        return data;\n      };\n\n      if (typeof scriptArgs != 'undefined') {\n        arguments_ = scriptArgs;\n      } else if (typeof arguments != 'undefined') {\n        arguments_ = arguments;\n      }\n\n      if (typeof quit === 'function') {\n        quit_ = function quit_(status) {\n          quit(status);\n        };\n      }\n\n      if (typeof print !== 'undefined') {\n        // Prefer to use print/printErr where they exist, as they usually work better.\n        if (typeof console === 'undefined') console = {};\n        console.log = print;\n        console.warn = console.error = typeof printErr !== 'undefined' ? printErr : print;\n      }\n    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        // Check worker, not web, since window could be polyfilled\n        scriptDirectory = self.location.href;\n      } else if (document.currentScript) {\n        // web\n        scriptDirectory = document.currentScript.src;\n      } // When MODULARIZE (and not _INSTANCE), this JS may be executed later, after document.currentScript\n      // is gone, so we saved it, and we use it here instead of any other info.\n\n\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      } // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n      // otherwise, slice off the final part of the url to find the script directory.\n      // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n      // and scriptDirectory will correctly be replaced with an empty string.\n\n\n      if (scriptDirectory.indexOf('blob:') !== 0) {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/') + 1);\n      } else {\n        scriptDirectory = '';\n      }\n\n      read_ = function shell_read(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.send(null);\n        return xhr.responseText;\n      };\n\n      if (ENVIRONMENT_IS_WORKER) {\n        readBinary = function readBinary(url) {\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', url, false);\n          xhr.responseType = 'arraybuffer';\n          xhr.send(null);\n          return new Uint8Array(xhr.response);\n        };\n      }\n\n      readAsync = function readAsync(url, onload, onerror) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.responseType = 'arraybuffer';\n\n        xhr.onload = function xhr_onload() {\n          if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n            // file URLs can return 0\n            onload(xhr.response);\n            return;\n          }\n\n          onerror();\n        };\n\n        xhr.onerror = onerror;\n        xhr.send(null);\n      };\n\n      setWindowTitle = function setWindowTitle(title) {\n        document.title = title;\n      };\n    } else {\n      throw new Error('environment detection error');\n    } // Set up the out() and err() hooks, which are how we can print to stdout or\n    // stderr, respectively.\n\n\n    var out = Module['print'] || console.log.bind(console);\n    var err = Module['printErr'] || console.warn.bind(console); // Merge back in the overrides\n\n    for (key in moduleOverrides) {\n      if (moduleOverrides.hasOwnProperty(key)) {\n        Module[key] = moduleOverrides[key];\n      }\n    } // Free the object hierarchy contained in the overrides, this lets the GC\n    // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\n\n\n    moduleOverrides = null; // Emit code to handle expected values on the Module object. This applies Module.x\n    // to the proper local x. This has two benefits: first, we only emit it if it is\n    // expected to arrive, and second, by using a local everywhere else that can be\n    // minified.\n\n    if (Module['arguments']) arguments_ = Module['arguments'];\n    if (!Object.getOwnPropertyDescriptor(Module, 'arguments')) Object.defineProperty(Module, 'arguments', {\n      configurable: true,\n      get: function get() {\n        abort('Module.arguments has been replaced with plain arguments_');\n      }\n    });\n    if (Module['thisProgram']) thisProgram = Module['thisProgram'];\n    if (!Object.getOwnPropertyDescriptor(Module, 'thisProgram')) Object.defineProperty(Module, 'thisProgram', {\n      configurable: true,\n      get: function get() {\n        abort('Module.thisProgram has been replaced with plain thisProgram');\n      }\n    });\n    if (Module['quit']) quit_ = Module['quit'];\n    if (!Object.getOwnPropertyDescriptor(Module, 'quit')) Object.defineProperty(Module, 'quit', {\n      configurable: true,\n      get: function get() {\n        abort('Module.quit has been replaced with plain quit_');\n      }\n    }); // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n    // Assertions on removed incoming Module JS APIs.\n\n    assert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['read'] === 'undefined', 'Module.read option was removed (modify read_ in JS)');\n    assert(typeof Module['readAsync'] === 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\n    assert(typeof Module['readBinary'] === 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\n    assert(typeof Module['setWindowTitle'] === 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');\n    if (!Object.getOwnPropertyDescriptor(Module, 'read')) Object.defineProperty(Module, 'read', {\n      configurable: true,\n      get: function get() {\n        abort('Module.read has been replaced with plain read_');\n      }\n    });\n    if (!Object.getOwnPropertyDescriptor(Module, 'readAsync')) Object.defineProperty(Module, 'readAsync', {\n      configurable: true,\n      get: function get() {\n        abort('Module.readAsync has been replaced with plain readAsync');\n      }\n    });\n    if (!Object.getOwnPropertyDescriptor(Module, 'readBinary')) Object.defineProperty(Module, 'readBinary', {\n      configurable: true,\n      get: function get() {\n        abort('Module.readBinary has been replaced with plain readBinary');\n      }\n    }); // TODO: add when SDL2 is fixed if (!Object.getOwnPropertyDescriptor(Module, 'setWindowTitle')) Object.defineProperty(Module, 'setWindowTitle', { configurable: true, get: function() { abort('Module.setWindowTitle has been replaced with plain setWindowTitle') } });\n    // TODO remove when SDL2 is fixed (also see above)\n    // Copyright 2017 The Emscripten Authors.  All rights reserved.\n    // Emscripten is available under two separate licenses, the MIT license and the\n    // University of Illinois/NCSA Open Source License.  Both these licenses can be\n    // found in the LICENSE file.\n    // {{PREAMBLE_ADDITIONS}}\n\n    var STACK_ALIGN = 16; // stack management, and other functionality that is provided by the compiled code,\n    // should not be used before it is ready\n\n    stackSave = stackRestore = stackAlloc = function stackAlloc() {\n      abort('cannot use the stack before compiled code is ready to run, and has provided stack access');\n    };\n\n    function staticAlloc(size) {\n      abort('staticAlloc is no longer available at runtime; instead, perform static allocations at compile time (using makeStaticAlloc)');\n    }\n\n    function dynamicAlloc(size) {\n      assert(DYNAMICTOP_PTR);\n      var ret = HEAP32[DYNAMICTOP_PTR >> 2];\n      var end = ret + size + 15 & -16;\n\n      if (end > _emscripten_get_heap_size()) {\n        abort('failure to dynamicAlloc - memory growth etc. is not supported there, call malloc/sbrk directly');\n      }\n\n      HEAP32[DYNAMICTOP_PTR >> 2] = end;\n      return ret;\n    }\n\n    function alignMemory(size, factor) {\n      if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n\n      return Math.ceil(size / factor) * factor;\n    }\n\n    function getNativeTypeSize(type) {\n      switch (type) {\n        case 'i1':\n        case 'i8':\n          return 1;\n\n        case 'i16':\n          return 2;\n\n        case 'i32':\n          return 4;\n\n        case 'i64':\n          return 8;\n\n        case 'float':\n          return 4;\n\n        case 'double':\n          return 8;\n\n        default:\n          {\n            if (type[type.length - 1] === '*') {\n              return 4; // A pointer\n            } else if (type[0] === 'i') {\n              var bits = parseInt(type.substr(1));\n              assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);\n              return bits / 8;\n            } else {\n              return 0;\n            }\n          }\n      }\n    }\n\n    function warnOnce(text) {\n      if (!warnOnce.shown) warnOnce.shown = {};\n\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        err(text);\n      }\n    }\n\n    var asm2wasmImports = {\n      // special asm2wasm imports\n      \"f64-rem\": function f64Rem(x, y) {\n        return x % y;\n      },\n      \"debugger\": function _debugger() {\n        debugger;\n      }\n    }; // Wraps a JS function as a wasm function with a given signature.\n    // In the future, we may get a WebAssembly.Function constructor. Until then,\n    // we create a wasm module that takes the JS function as an import with a given\n    // signature, and re-exports that as a wasm function.\n\n    function convertJsFunctionToWasm(func, sig) {\n      // The module is static, with the exception of the type section, which is\n      // generated based on the signature passed in.\n      var typeSection = [0x01, // id: section,\n      0x00, // length: 0 (placeholder)\n      0x01, // count: 1\n      0x60 // form: func\n      ];\n      var sigRet = sig.slice(0, 1);\n      var sigParam = sig.slice(1);\n      var typeCodes = {\n        'i': 0x7f,\n        // i32\n        'j': 0x7e,\n        // i64\n        'f': 0x7d,\n        // f32\n        'd': 0x7c // f64\n\n      }; // Parameters, length + signatures\n\n      typeSection.push(sigParam.length);\n\n      for (var i = 0; i < sigParam.length; ++i) {\n        typeSection.push(typeCodes[sigParam[i]]);\n      } // Return values, length + signatures\n      // With no multi-return in MVP, either 0 (void) or 1 (anything else)\n\n\n      if (sigRet == 'v') {\n        typeSection.push(0x00);\n      } else {\n        typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);\n      } // Write the overall length of the type section back into the section header\n      // (excepting the 2 bytes for the section id and length)\n\n\n      typeSection[1] = typeSection.length - 2; // Rest of the module is static\n\n      var bytes = new Uint8Array([0x00, 0x61, 0x73, 0x6d, // magic (\"\\0asm\")\n      0x01, 0x00, 0x00, 0x00 // version: 1\n      ].concat(typeSection, [0x02, 0x07, // import section\n      // (import \"e\" \"f\" (func 0 (type 0)))\n      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00, 0x07, 0x05, // export section\n      // (export \"f\" (func 0 (type 0)))\n      0x01, 0x01, 0x66, 0x00, 0x00])); // We can compile this wasm module synchronously because it is very small.\n      // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\n\n      var module = new WebAssembly.Module(bytes);\n      var instance = new WebAssembly.Instance(module, {\n        e: {\n          f: func\n        }\n      });\n      var wrappedFunc = instance.exports.f;\n      return wrappedFunc;\n    } // Add a wasm function to the table.\n\n\n    function addFunctionWasm(func, sig) {\n      var table = wasmTable;\n      var ret = table.length; // Grow the table\n\n      try {\n        table.grow(1);\n      } catch (err) {\n        if (!err instanceof RangeError) {\n          throw err;\n        }\n\n        throw 'Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.';\n      } // Insert new element\n\n\n      try {\n        // Attempting to call this with JS function will cause of table.set() to fail\n        table.set(ret, func);\n      } catch (err) {\n        if (!err instanceof TypeError) {\n          throw err;\n        }\n\n        assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction');\n        var wrapped = convertJsFunctionToWasm(func, sig);\n        table.set(ret, wrapped);\n      }\n\n      return ret;\n    }\n\n    function removeFunctionWasm(index) {} // TODO(sbc): Look into implementing this to allow re-using of table slots\n    // 'sig' parameter is required for the llvm backend but only when func is not\n    // already a WebAssembly function.\n\n\n    function addFunction(func, sig) {\n      assert(typeof func !== 'undefined');\n      return addFunctionWasm(func, sig);\n    }\n\n    function removeFunction(index) {\n      removeFunctionWasm(index);\n    }\n\n    var funcWrappers = {};\n\n    function getFuncWrapper(func, sig) {\n      if (!func) return; // on null pointer, return undefined\n\n      assert(sig);\n\n      if (!funcWrappers[sig]) {\n        funcWrappers[sig] = {};\n      }\n\n      var sigCache = funcWrappers[sig];\n\n      if (!sigCache[func]) {\n        // optimize away arguments usage in common cases\n        if (sig.length === 1) {\n          sigCache[func] = function dynCall_wrapper() {\n            return dynCall(sig, func);\n          };\n        } else if (sig.length === 2) {\n          sigCache[func] = function dynCall_wrapper(arg) {\n            return dynCall(sig, func, [arg]);\n          };\n        } else {\n          // general case\n          sigCache[func] = function dynCall_wrapper() {\n            return dynCall(sig, func, Array.prototype.slice.call(arguments));\n          };\n        }\n      }\n\n      return sigCache[func];\n    }\n\n    function makeBigInt(low, high, unsigned) {\n      return unsigned ? +(low >>> 0) + +(high >>> 0) * 4294967296.0 : +(low >>> 0) + +(high | 0) * 4294967296.0;\n    }\n\n    function dynCall(sig, ptr, args) {\n      if (args && args.length) {\n        assert(args.length == sig.length - 1);\n        assert('dynCall_' + sig in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n        return Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n      } else {\n        assert(sig.length == 1);\n        assert('dynCall_' + sig in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n        return Module['dynCall_' + sig].call(null, ptr);\n      }\n    }\n\n    var tempRet0 = 0;\n\n    var setTempRet0 = function setTempRet0(value) {\n      tempRet0 = value;\n    };\n\n    var getTempRet0 = function getTempRet0() {\n      return tempRet0;\n    };\n\n    function getCompilerSetting(name) {\n      throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';\n    }\n\n    var Runtime = {\n      // helpful errors\n      getTempRet0: function getTempRet0() {\n        abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n      },\n      staticAlloc: function staticAlloc() {\n        abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n      },\n      stackAlloc: function stackAlloc() {\n        abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n      }\n    }; // The address globals begin at. Very low in memory, for code size and optimization opportunities.\n    // Above 0 is static memory, starting with globals.\n    // Then the stack.\n    // Then 'dynamic' memory for sbrk.\n\n    var GLOBAL_BASE = 1024; // === Preamble library stuff ===\n    // Documentation for the public APIs defined in this file must be updated in:\n    //    site/source/docs/api_reference/preamble.js.rst\n    // A prebuilt local version of the documentation is available at:\n    //    site/build/text/docs/api_reference/preamble.js.txt\n    // You can also build docs locally as HTML or other formats in site/\n    // An online HTML version (which may be of a different version of Emscripten)\n    //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n    var wasmBinary;\n    if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\n    if (!Object.getOwnPropertyDescriptor(Module, 'wasmBinary')) Object.defineProperty(Module, 'wasmBinary', {\n      configurable: true,\n      get: function get() {\n        abort('Module.wasmBinary has been replaced with plain wasmBinary');\n      }\n    });\n    var noExitRuntime;\n    if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];\n    if (!Object.getOwnPropertyDescriptor(Module, 'noExitRuntime')) Object.defineProperty(Module, 'noExitRuntime', {\n      configurable: true,\n      get: function get() {\n        abort('Module.noExitRuntime has been replaced with plain noExitRuntime');\n      }\n    });\n\n    if ((typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) !== 'object') {\n      abort('No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.');\n    } // In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.\n    // In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)\n\n    /** @type {function(number, number, string, boolean=)} */\n\n\n    function setValue(ptr, value, type, noSafe) {\n      type = type || 'i8';\n      if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n      switch (type) {\n        case 'i1':\n          HEAP8[ptr >> 0] = value;\n          break;\n\n        case 'i8':\n          HEAP8[ptr >> 0] = value;\n          break;\n\n        case 'i16':\n          HEAP16[ptr >> 1] = value;\n          break;\n\n        case 'i32':\n          HEAP32[ptr >> 2] = value;\n          break;\n\n        case 'i64':\n          tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? (Math_min(+Math_floor(tempDouble / 4294967296.0), 4294967295.0) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n          break;\n\n        case 'float':\n          HEAPF32[ptr >> 2] = value;\n          break;\n\n        case 'double':\n          HEAPF64[ptr >> 3] = value;\n          break;\n\n        default:\n          abort('invalid type for setValue: ' + type);\n      }\n    }\n    /** @type {function(number, string, boolean=)} */\n\n\n    function getValue(ptr, type, noSafe) {\n      type = type || 'i8';\n      if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n      switch (type) {\n        case 'i1':\n          return HEAP8[ptr >> 0];\n\n        case 'i8':\n          return HEAP8[ptr >> 0];\n\n        case 'i16':\n          return HEAP16[ptr >> 1];\n\n        case 'i32':\n          return HEAP32[ptr >> 2];\n\n        case 'i64':\n          return HEAP32[ptr >> 2];\n\n        case 'float':\n          return HEAPF32[ptr >> 2];\n\n        case 'double':\n          return HEAPF64[ptr >> 3];\n\n        default:\n          abort('invalid type for getValue: ' + type);\n      }\n\n      return null;\n    } // Wasm globals\n\n\n    var wasmMemory; // In fastcomp asm.js, we don't need a wasm Table at all.\n    // In the wasm backend, we polyfill the WebAssembly object,\n    // so this creates a (non-native-wasm) table for us.\n\n    var wasmTable = new WebAssembly.Table({\n      'initial': 3420,\n      'maximum': 3420 + 0,\n      'element': 'anyfunc'\n    }); //========================================\n    // Runtime essentials\n    //========================================\n    // whether we are quitting the application. no code should run after this.\n    // set in exit() and abort()\n\n    var ABORT = false; // set by exit() and abort().  Passed to 'onExit' handler.\n    // NOTE: This is also used as the process return code code in shell environments\n    // but only when noExitRuntime is false.\n\n    var EXITSTATUS = 0;\n    /** @type {function(*, string=)} */\n\n    function assert(condition, text) {\n      if (!condition) {\n        abort('Assertion failed: ' + text);\n      }\n    } // Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\n\n\n    function getCFunc(ident) {\n      var func = Module['_' + ident]; // closure exported function\n\n      assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n      return func;\n    } // C calling interface.\n\n\n    function ccall(ident, returnType, argTypes, args, opts) {\n      // For fast lookup of conversion functions\n      var toC = {\n        'string': function string(str) {\n          var ret = 0;\n\n          if (str !== null && str !== undefined && str !== 0) {\n            // null string\n            // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n            var len = (str.length << 2) + 1;\n            ret = stackAlloc(len);\n            stringToUTF8(str, ret, len);\n          }\n\n          return ret;\n        },\n        'array': function array(arr) {\n          var ret = stackAlloc(arr.length);\n          writeArrayToMemory(arr, ret);\n          return ret;\n        }\n      };\n\n      function convertReturnValue(ret) {\n        if (returnType === 'string') return UTF8ToString(ret);\n        if (returnType === 'boolean') return Boolean(ret);\n        return ret;\n      }\n\n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      assert(returnType !== 'array', 'Return type should not be \"array\".');\n\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n\n          if (converter) {\n            if (stack === 0) stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n\n      var ret = func.apply(null, cArgs);\n      ret = convertReturnValue(ret);\n      if (stack !== 0) stackRestore(stack);\n      return ret;\n    }\n\n    function cwrap(ident, returnType, argTypes, opts) {\n      return function () {\n        return ccall(ident, returnType, argTypes, arguments, opts);\n      };\n    }\n\n    var ALLOC_NORMAL = 0; // Tries to use _malloc()\n\n    var ALLOC_STACK = 1; // Lives for the duration of the current function call\n\n    var ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk\n\n    var ALLOC_NONE = 3; // Do not allocate\n    // allocate(): This is for internal use. You can use it yourself as well, but the interface\n    //             is a little tricky (see docs right below). The reason is that it is optimized\n    //             for multiple syntaxes to save space in generated code. So you should\n    //             normally not use allocate(), and instead allocate memory using _malloc(),\n    //             initialize it with setValue(), and so forth.\n    // @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n    //        in *bytes* (note that this is sometimes confusing: the next parameter does not\n    //        affect this!)\n    // @types: Either an array of types, one for each byte (or 0 if no type at that position),\n    //         or a single type which is used for the entire block. This only matters if there\n    //         is initial data - if @slab is a number, then this does not matter at all and is\n    //         ignored.\n    // @allocator: How to allocate memory, see ALLOC_*\n\n    /** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\n\n    function allocate(slab, types, allocator, ptr) {\n      var zeroinit, size;\n\n      if (typeof slab === 'number') {\n        zeroinit = true;\n        size = slab;\n      } else {\n        zeroinit = false;\n        size = slab.length;\n      }\n\n      var singleType = typeof types === 'string' ? types : null;\n      var ret;\n\n      if (allocator == ALLOC_NONE) {\n        ret = ptr;\n      } else {\n        ret = [_malloc, stackAlloc, dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));\n      }\n\n      if (zeroinit) {\n        var stop;\n        ptr = ret;\n        assert((ret & 3) == 0);\n        stop = ret + (size & ~3);\n\n        for (; ptr < stop; ptr += 4) {\n          HEAP32[ptr >> 2] = 0;\n        }\n\n        stop = ret + size;\n\n        while (ptr < stop) {\n          HEAP8[ptr++ >> 0] = 0;\n        }\n\n        return ret;\n      }\n\n      if (singleType === 'i8') {\n        if (slab.subarray || slab.slice) {\n          HEAPU8.set(\n          /** @type {!Uint8Array} */\n          slab, ret);\n        } else {\n          HEAPU8.set(new Uint8Array(slab), ret);\n        }\n\n        return ret;\n      }\n\n      var i = 0,\n          type,\n          typeSize,\n          previousType;\n\n      while (i < size) {\n        var curr = slab[i];\n        type = singleType || types[i];\n\n        if (type === 0) {\n          i++;\n          continue;\n        }\n\n        assert(type, 'Must know what type to store in allocate!');\n        if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n        setValue(ret + i, curr, type); // no need to look up size unless type changes, so cache it\n\n        if (previousType !== type) {\n          typeSize = getNativeTypeSize(type);\n          previousType = type;\n        }\n\n        i += typeSize;\n      }\n\n      return ret;\n    } // Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\n\n\n    function getMemory(size) {\n      if (!runtimeInitialized) return dynamicAlloc(size);\n      return _malloc(size);\n    }\n    /** @type {function(number, number=)} */\n\n\n    function Pointer_stringify(ptr, length) {\n      abort(\"this function has been removed - you should use UTF8ToString(ptr, maxBytesToRead) instead!\");\n    } // Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n    // a copy of that string as a Javascript String object.\n\n\n    function AsciiToString(ptr) {\n      var str = '';\n\n      while (1) {\n        var ch = HEAPU8[ptr++ >> 0];\n        if (!ch) return str;\n        str += String.fromCharCode(ch);\n      }\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\n\n    function stringToAscii(str, outPtr) {\n      return writeAsciiToMemory(str, outPtr, false);\n    } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n    // a copy of that string as a Javascript String object.\n\n\n    var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n    /**\n     * @param {number} idx\n     * @param {number=} maxBytesToRead\n     * @return {string}\n     */\n\n    function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n      // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n      // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\n\n      while (u8Array[endPtr] && !(endPtr >= endIdx)) {\n        ++endPtr;\n      }\n\n      if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n        return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n      } else {\n        var str = ''; // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\n\n        while (idx < endPtr) {\n          // For UTF8 byte structure, see:\n          // http://en.wikipedia.org/wiki/UTF-8#Description\n          // https://www.ietf.org/rfc/rfc2279.txt\n          // https://tools.ietf.org/html/rfc3629\n          var u0 = u8Array[idx++];\n\n          if (!(u0 & 0x80)) {\n            str += String.fromCharCode(u0);\n            continue;\n          }\n\n          var u1 = u8Array[idx++] & 63;\n\n          if ((u0 & 0xE0) == 0xC0) {\n            str += String.fromCharCode((u0 & 31) << 6 | u1);\n            continue;\n          }\n\n          var u2 = u8Array[idx++] & 63;\n\n          if ((u0 & 0xF0) == 0xE0) {\n            u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n          } else {\n            if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!');\n            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;\n          }\n\n          if (u0 < 0x10000) {\n            str += String.fromCharCode(u0);\n          } else {\n            var ch = u0 - 0x10000;\n            str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n          }\n        }\n      }\n\n      return str;\n    } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\n    // copy of that string as a Javascript String object.\n    // maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\n    //                 this parameter to scan the string until the first \\0 byte. If maxBytesToRead is\n    //                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\n    //                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\n    //                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\n    //                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\n    //                 throw JS JIT optimizations off, so it is worth to consider consistently using one\n    //                 style or the other.\n\n    /**\n     * @param {number} ptr\n     * @param {number=} maxBytesToRead\n     * @return {string}\n     */\n\n\n    function UTF8ToString(ptr, maxBytesToRead) {\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n    } // Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n    // encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Parameters:\n    //   str: the Javascript string to copy.\n    //   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n    //   outIdx: The starting offset in the array to begin the copying.\n    //   maxBytesToWrite: The maximum number of bytes this function can write to the array.\n    //                    This count should include the null terminator,\n    //                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n    //                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n      if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n        return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n\n        if (u >= 0xD800 && u <= 0xDFFF) {\n          var u1 = str.charCodeAt(++i);\n          u = 0x10000 + ((u & 0x3FF) << 10) | u1 & 0x3FF;\n        }\n\n        if (u <= 0x7F) {\n          if (outIdx >= endIdx) break;\n          outU8Array[outIdx++] = u;\n        } else if (u <= 0x7FF) {\n          if (outIdx + 1 >= endIdx) break;\n          outU8Array[outIdx++] = 0xC0 | u >> 6;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        } else if (u <= 0xFFFF) {\n          if (outIdx + 2 >= endIdx) break;\n          outU8Array[outIdx++] = 0xE0 | u >> 12;\n          outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          if (u >= 0x200000) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).');\n          outU8Array[outIdx++] = 0xF0 | u >> 18;\n          outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n          outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        }\n      } // Null-terminate the pointer to the buffer.\n\n\n      outU8Array[outIdx] = 0;\n      return outIdx - startIdx;\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF8(str, outPtr, maxBytesToWrite) {\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    } // Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\n\n\n    function lengthBytesUTF8(str) {\n      var len = 0;\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n\n        if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;\n        if (u <= 0x7F) ++len;else if (u <= 0x7FF) len += 2;else if (u <= 0xFFFF) len += 3;else len += 4;\n      }\n\n      return len;\n    } // Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n    // a copy of that string as a Javascript String object.\n\n\n    var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\n\n    function UTF16ToString(ptr) {\n      assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n      var endPtr = ptr; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n      // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n\n      var idx = endPtr >> 1;\n\n      while (HEAP16[idx]) {\n        ++idx;\n      }\n\n      endPtr = idx << 1;\n\n      if (endPtr - ptr > 32 && UTF16Decoder) {\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n      } else {\n        var i = 0;\n        var str = '';\n\n        while (1) {\n          var codeUnit = HEAP16[ptr + i * 2 >> 1];\n          if (codeUnit == 0) return str;\n          ++i; // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n\n          str += String.fromCharCode(codeUnit);\n        }\n      }\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Parameters:\n    //   str: the Javascript string to copy.\n    //   outPtr: Byte address in Emscripten HEAP where to write the string to.\n    //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n    //                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n    //                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF16(str, outPtr, maxBytesToWrite) {\n      assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 0x7FFFFFFF;\n      }\n\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2; // Null terminator.\n\n      var startPtr = outPtr;\n      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n        HEAP16[outPtr >> 1] = codeUnit;\n        outPtr += 2;\n      } // Null-terminate the pointer to the HEAP.\n\n\n      HEAP16[outPtr >> 1] = 0;\n      return outPtr - startPtr;\n    } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\n    function lengthBytesUTF16(str) {\n      return str.length * 2;\n    }\n\n    function UTF32ToString(ptr) {\n      assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n      var i = 0;\n      var str = '';\n\n      while (1) {\n        var utf32 = HEAP32[ptr + i * 4 >> 2];\n        if (utf32 == 0) return str;\n        ++i; // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n\n        if (utf32 >= 0x10000) {\n          var ch = utf32 - 0x10000;\n          str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n        } else {\n          str += String.fromCharCode(utf32);\n        }\n      }\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Parameters:\n    //   str: the Javascript string to copy.\n    //   outPtr: Byte address in Emscripten HEAP where to write the string to.\n    //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n    //                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n    //                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF32(str, outPtr, maxBytesToWrite) {\n      assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 0x7FFFFFFF;\n      }\n\n      if (maxBytesToWrite < 4) return 0;\n      var startPtr = outPtr;\n      var endPtr = startPtr + maxBytesToWrite - 4;\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n          var trailSurrogate = str.charCodeAt(++i);\n          codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | trailSurrogate & 0x3FF;\n        }\n\n        HEAP32[outPtr >> 2] = codeUnit;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr) break;\n      } // Null-terminate the pointer to the HEAP.\n\n\n      HEAP32[outPtr >> 2] = 0;\n      return outPtr - startPtr;\n    } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\n    function lengthBytesUTF32(str) {\n      var len = 0;\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n\n        len += 4;\n      }\n\n      return len;\n    } // Allocate heap space for a JS string, and write it there.\n    // It is the responsibility of the caller to free() that memory.\n\n\n    function allocateUTF8(str) {\n      var size = lengthBytesUTF8(str) + 1;\n\n      var ret = _malloc(size);\n\n      if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n      return ret;\n    } // Allocate stack space for a JS string, and write it there.\n\n\n    function allocateUTF8OnStack(str) {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = stackAlloc(size);\n      stringToUTF8Array(str, HEAP8, ret, size);\n      return ret;\n    } // Deprecated: This function should not be called because it is unsafe and does not provide\n    // a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n    // function stringToUTF8Array() instead, which takes in a maximum length that can be used\n    // to be secure from out of bounds writes.\n\n    /** @deprecated */\n\n\n    function writeStringToMemory(string, buffer, dontAddNull) {\n      warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n      var\n      /** @type {number} */\n      lastChar,\n      /** @type {number} */\n      end;\n\n      if (dontAddNull) {\n        // stringToUTF8Array always appends null. If we don't want to do that, remember the\n        // character that existed at the location where the null will be placed, and restore\n        // that after the write (below).\n        end = buffer + lengthBytesUTF8(string);\n        lastChar = HEAP8[end];\n      }\n\n      stringToUTF8(string, buffer, Infinity);\n      if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n    }\n\n    function writeArrayToMemory(array, buffer) {\n      assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)');\n      HEAP8.set(array, buffer);\n    }\n\n    function writeAsciiToMemory(str, buffer, dontAddNull) {\n      for (var i = 0; i < str.length; ++i) {\n        assert(str.charCodeAt(i) === str.charCodeAt(i) & 0xff);\n        HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n      } // Null-terminate the pointer to the HEAP.\n\n\n      if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n    } // Memory management\n\n\n    var PAGE_SIZE = 16384;\n    var WASM_PAGE_SIZE = 65536;\n    var ASMJS_PAGE_SIZE = 16777216;\n\n    function alignUp(x, multiple) {\n      if (x % multiple > 0) {\n        x += multiple - x % multiple;\n      }\n\n      return x;\n    }\n\n    var HEAP,\n    /** @type {ArrayBuffer} */\n    buffer,\n    /** @type {Int8Array} */\n    HEAP8,\n    /** @type {Uint8Array} */\n    HEAPU8,\n    /** @type {Int16Array} */\n    HEAP16,\n    /** @type {Uint16Array} */\n    HEAPU16,\n    /** @type {Int32Array} */\n    HEAP32,\n    /** @type {Uint32Array} */\n    HEAPU32,\n    /** @type {Float32Array} */\n    HEAPF32,\n    /** @type {Float64Array} */\n    HEAPF64;\n\n    function updateGlobalBufferAndViews(buf) {\n      buffer = buf;\n      Module['HEAP8'] = HEAP8 = new Int8Array(buf);\n      Module['HEAP16'] = HEAP16 = new Int16Array(buf);\n      Module['HEAP32'] = HEAP32 = new Int32Array(buf);\n      Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\n      Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);\n      Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\n      Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);\n      Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);\n    }\n\n    var STATIC_BASE = 1024,\n        STACK_BASE = 7642544,\n        STACKTOP = STACK_BASE,\n        STACK_MAX = 2399664,\n        DYNAMIC_BASE = 7642544,\n        DYNAMICTOP_PTR = 2399504;\n    assert(STACK_BASE % 16 === 0, 'stack must start aligned');\n    assert(DYNAMIC_BASE % 16 === 0, 'heap must start aligned');\n    var TOTAL_STACK = 5242880;\n    if (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime');\n    var INITIAL_TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;\n    if (!Object.getOwnPropertyDescriptor(Module, 'TOTAL_MEMORY')) Object.defineProperty(Module, 'TOTAL_MEMORY', {\n      configurable: true,\n      get: function get() {\n        abort('Module.TOTAL_MEMORY has been replaced with plain INITIAL_TOTAL_MEMORY');\n      }\n    });\n    assert(INITIAL_TOTAL_MEMORY >= TOTAL_STACK, 'TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')'); // check for full engine support (use string 'subarray' to avoid closure compiler confusion)\n\n    assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, 'JS engine does not provide full typed array support'); // In standalone mode, the wasm creates the memory, and the user can't provide it.\n    // In non-standalone/normal mode, we create the memory here.\n    // Create the main memory. (Note: this isn't used in STANDALONE_WASM mode since the wasm\n    // memory is created in the wasm, not in JS.)\n\n    if (Module['wasmMemory']) {\n      wasmMemory = Module['wasmMemory'];\n    } else {\n      wasmMemory = new WebAssembly.Memory({\n        'initial': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE\n      });\n    }\n\n    if (wasmMemory) {\n      buffer = wasmMemory.buffer;\n    } // If the user provides an incorrect length, just use that length instead rather than providing the user to\n    // specifically provide the memory length with Module['TOTAL_MEMORY'].\n\n\n    INITIAL_TOTAL_MEMORY = buffer.byteLength;\n    assert(INITIAL_TOTAL_MEMORY % WASM_PAGE_SIZE === 0);\n    updateGlobalBufferAndViews(buffer);\n    HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE; // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\n\n    function writeStackCookie() {\n      assert((STACK_MAX & 3) == 0); // The stack grows downwards\n\n      HEAPU32[(STACK_MAX >> 2) + 1] = 0x02135467;\n      HEAPU32[(STACK_MAX >> 2) + 2] = 0x89BACDFE; // Also test the global address 0 for integrity.\n      // We don't do this with ASan because ASan does its own checks for this.\n\n      HEAP32[0] = 0x63736d65;\n      /* 'emsc' */\n    }\n\n    function checkStackCookie() {\n      var cookie1 = HEAPU32[(STACK_MAX >> 2) + 1];\n      var cookie2 = HEAPU32[(STACK_MAX >> 2) + 2];\n\n      if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {\n        abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x' + cookie2.toString(16) + ' ' + cookie1.toString(16));\n      } // Also test the global address 0 for integrity.\n      // We don't do this with ASan because ASan does its own checks for this.\n\n\n      if (HEAP32[0] !== 0x63736d65\n      /* 'emsc' */\n      ) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n    }\n\n    function abortStackOverflow(allocSize) {\n      abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');\n    } // Endianness check (note: assumes compiler arch was little-endian)\n\n\n    (function () {\n      var h16 = new Int16Array(1);\n      var h8 = new Int8Array(h16.buffer);\n      h16[0] = 0x6373;\n      if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';\n    })();\n\n    function abortFnPtrError(ptr, sig) {\n      abort(\"Invalid function pointer \" + ptr + \" called with signature '\" + sig + \"'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this). Build with ASSERTIONS=2 for more info.\");\n    }\n\n    function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        var callback = callbacks.shift();\n\n        if (typeof callback == 'function') {\n          callback();\n          continue;\n        }\n\n        var func = callback.func;\n\n        if (typeof func === 'number') {\n          if (callback.arg === undefined) {\n            Module['dynCall_v'](func);\n          } else {\n            Module['dynCall_vi'](func, callback.arg);\n          }\n        } else {\n          func(callback.arg === undefined ? null : callback.arg);\n        }\n      }\n    }\n\n    var __ATPRERUN__ = []; // functions called before the runtime is initialized\n\n    var __ATINIT__ = []; // functions called during startup\n\n    var __ATMAIN__ = []; // functions called when main() is to be run\n\n    var __ATEXIT__ = []; // functions called during shutdown\n\n    var __ATPOSTRUN__ = []; // functions called after the main() is called\n\n    var runtimeInitialized = false;\n    var runtimeExited = false;\n\n    function preRun() {\n      if (Module['preRun']) {\n        if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n\n        while (Module['preRun'].length) {\n          addOnPreRun(Module['preRun'].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n\n    function initRuntime() {\n      checkStackCookie();\n      assert(!runtimeInitialized);\n      runtimeInitialized = true;\n      callRuntimeCallbacks(__ATINIT__);\n    }\n\n    function preMain() {\n      checkStackCookie();\n      callRuntimeCallbacks(__ATMAIN__);\n    }\n\n    function exitRuntime() {\n      checkStackCookie();\n      runtimeExited = true;\n    }\n\n    function postRun() {\n      checkStackCookie();\n\n      if (Module['postRun']) {\n        if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n\n        while (Module['postRun'].length) {\n          addOnPostRun(Module['postRun'].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n\n    function addOnPreMain(cb) {\n      __ATMAIN__.unshift(cb);\n    }\n\n    function addOnExit(cb) {}\n\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n\n    function unSign(value, bits, ignore) {\n      if (value >= 0) {\n        return value;\n      }\n\n      return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n      : Math.pow(2, bits) + value;\n    }\n\n    function reSign(value, bits, ignore) {\n      if (value <= 0) {\n        return value;\n      }\n\n      var half = bits <= 32 ? Math.abs(1 << bits - 1) // abs is needed if bits == 32\n      : Math.pow(2, bits - 1);\n\n      if (value >= half && (bits <= 32 || value > half)) {\n        // for huge values, we can hit the precision limit and always get true here. so don't do that\n        // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n        // TODO: In i64 mode 1, resign the two parts separately and safely\n        value = -2 * half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n      }\n\n      return value;\n    }\n\n    assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n    assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n    assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n    assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n    var Math_abs = Math.abs;\n    var Math_cos = Math.cos;\n    var Math_sin = Math.sin;\n    var Math_tan = Math.tan;\n    var Math_acos = Math.acos;\n    var Math_asin = Math.asin;\n    var Math_atan = Math.atan;\n    var Math_atan2 = Math.atan2;\n    var Math_exp = Math.exp;\n    var Math_log = Math.log;\n    var Math_sqrt = Math.sqrt;\n    var Math_ceil = Math.ceil;\n    var Math_floor = Math.floor;\n    var Math_pow = Math.pow;\n    var Math_imul = Math.imul;\n    var Math_fround = Math.fround;\n    var Math_round = Math.round;\n    var Math_min = Math.min;\n    var Math_max = Math.max;\n    var Math_clz32 = Math.clz32;\n    var Math_trunc = Math.trunc; // A counter of dependencies for calling run(). If we need to\n    // do asynchronous work before running, increment this and\n    // decrement it. Incrementing must happen in a place like\n    // Module.preRun (used by emcc to add file preloading).\n    // Note that you can add dependencies in preRun, even though\n    // it happens right before run - run will be postponed until\n    // the dependencies are met.\n\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\n    var runDependencyTracking = {};\n\n    function getUniqueRunDependency(id) {\n      var orig = id;\n\n      while (1) {\n        if (!runDependencyTracking[id]) return id;\n        id = orig + Math.random();\n      }\n\n      return id;\n    }\n\n    function addRunDependency(id) {\n      runDependencies++;\n\n      if (Module['monitorRunDependencies']) {\n        Module['monitorRunDependencies'](runDependencies);\n      }\n\n      if (id) {\n        assert(!runDependencyTracking[id]);\n        runDependencyTracking[id] = 1;\n\n        if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\n          // Check for missing dependencies every few seconds\n          runDependencyWatcher = setInterval(function () {\n            if (ABORT) {\n              clearInterval(runDependencyWatcher);\n              runDependencyWatcher = null;\n              return;\n            }\n\n            var shown = false;\n\n            for (var dep in runDependencyTracking) {\n              if (!shown) {\n                shown = true;\n                err('still waiting on run dependencies:');\n              }\n\n              err('dependency: ' + dep);\n            }\n\n            if (shown) {\n              err('(end of list)');\n            }\n          }, 10000);\n        }\n      } else {\n        err('warning: run dependency added without ID');\n      }\n    }\n\n    function removeRunDependency(id) {\n      runDependencies--;\n\n      if (Module['monitorRunDependencies']) {\n        Module['monitorRunDependencies'](runDependencies);\n      }\n\n      if (id) {\n        assert(runDependencyTracking[id]);\n        delete runDependencyTracking[id];\n      } else {\n        err('warning: run dependency removed without ID');\n      }\n\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback(); // can add another dependenciesFulfilled\n        }\n      }\n    }\n\n    Module[\"preloadedImages\"] = {}; // maps url to image data\n\n    Module[\"preloadedAudios\"] = {}; // maps url to audio data\n\n    function abort(what) {\n      if (Module['onAbort']) {\n        Module['onAbort'](what);\n      }\n\n      what += '';\n      out(what);\n      err(what);\n      ABORT = true;\n      EXITSTATUS = 1;\n      var extra = '';\n      var output = 'abort(' + what + ') at ' + stackTrace() + extra;\n      throw output;\n    }\n\n    var memoryInitializer = null; // show errors on likely calls to FS when it was not included\n\n    var FS = {\n      error: function error() {\n        abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');\n      },\n      init: function init() {\n        FS.error();\n      },\n      createDataFile: function createDataFile() {\n        FS.error();\n      },\n      createPreloadedFile: function createPreloadedFile() {\n        FS.error();\n      },\n      createLazyFile: function createLazyFile() {\n        FS.error();\n      },\n      open: function open() {\n        FS.error();\n      },\n      mkdev: function mkdev() {\n        FS.error();\n      },\n      registerDevice: function registerDevice() {\n        FS.error();\n      },\n      analyzePath: function analyzePath() {\n        FS.error();\n      },\n      loadFilesFromDB: function loadFilesFromDB() {\n        FS.error();\n      },\n      ErrnoError: function ErrnoError() {\n        FS.error();\n      }\n    };\n    Module['FS_createDataFile'] = FS.createDataFile;\n    Module['FS_createPreloadedFile'] = FS.createPreloadedFile; // Copyright 2017 The Emscripten Authors.  All rights reserved.\n    // Emscripten is available under two separate licenses, the MIT license and the\n    // University of Illinois/NCSA Open Source License.  Both these licenses can be\n    // found in the LICENSE file.\n    // Prefix of data URIs emitted by SINGLE_FILE and related options.\n\n    var dataURIPrefix = 'data:application/octet-stream;base64,'; // Indicates whether filename is a base64 data URI.\n\n    function isDataURI(filename) {\n      return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;\n    }\n\n    var wasmBinaryFile = 'genplus.wasm';\n\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = locateFile(wasmBinaryFile);\n    }\n\n    function getBinary() {\n      try {\n        if (wasmBinary) {\n          return new Uint8Array(wasmBinary);\n        }\n\n        if (readBinary) {\n          return readBinary(wasmBinaryFile);\n        } else {\n          throw \"both async and sync fetching of the wasm failed\";\n        }\n      } catch (err) {\n        abort(err);\n      }\n    }\n\n    function getBinaryPromise() {\n      // if we don't have the binary yet, and have the Fetch api, use that\n      // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\n      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n        return fetch(wasmBinaryFile, {\n          credentials: 'same-origin'\n        }).then(function (response) {\n          if (!response['ok']) {\n            throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n          }\n\n          return response['arrayBuffer']();\n        })[\"catch\"](function () {\n          return getBinary();\n        });\n      } // Otherwise, getBinary should be able to get it synchronously\n\n\n      return new Promise(function (resolve, reject) {\n        resolve(getBinary());\n      });\n    } // Create the wasm instance.\n    // Receives the wasm imports, returns the exports.\n\n\n    function createWasm() {\n      // prepare imports\n      var info = {\n        'env': asmLibraryArg,\n        'wasi_unstable': asmLibraryArg\n      }; // Load the wasm module and create an instance of using native support in the JS engine.\n      // handle a generated wasm instance, receiving its exports and\n      // performing other necessary setup\n\n      function receiveInstance(instance, module) {\n        var exports = instance.exports;\n        Module['asm'] = exports;\n        removeRunDependency('wasm-instantiate');\n      } // we can't run yet (except in a pthread, where we have a custom sync instantiator)\n\n\n      addRunDependency('wasm-instantiate'); // Async compilation can be confusing when an error on the page overwrites Module\n      // (for example, if the order of elements is wrong, and the one defining Module is\n      // later), so we save Module and check it later.\n\n      var trueModule = Module;\n\n      function receiveInstantiatedSource(output) {\n        // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\n        // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n        assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n        trueModule = null; // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n        // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\n\n        receiveInstance(output['instance']);\n      }\n\n      function instantiateArrayBuffer(receiver) {\n        return getBinaryPromise().then(function (binary) {\n          return WebAssembly.instantiate(binary, info);\n        }).then(receiver, function (reason) {\n          err('failed to asynchronously prepare wasm: ' + reason);\n          abort(reason);\n        });\n      } // Prefer streaming instantiation if available.\n\n\n      function instantiateAsync() {\n        if (!wasmBinary && typeof WebAssembly.instantiateStreaming === 'function' && !isDataURI(wasmBinaryFile) && typeof fetch === 'function') {\n          fetch(wasmBinaryFile, {\n            credentials: 'same-origin'\n          }).then(function (response) {\n            var result = WebAssembly.instantiateStreaming(response, info);\n            return result.then(receiveInstantiatedSource, function (reason) {\n              // We expect the most common failure cause to be a bad MIME type for the binary,\n              // in which case falling back to ArrayBuffer instantiation should work.\n              err('wasm streaming compile failed: ' + reason);\n              err('falling back to ArrayBuffer instantiation');\n              instantiateArrayBuffer(receiveInstantiatedSource);\n            });\n          });\n        } else {\n          return instantiateArrayBuffer(receiveInstantiatedSource);\n        }\n      } // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n      // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n      // to any other async startup actions they are performing.\n\n\n      if (Module['instantiateWasm']) {\n        try {\n          var exports = Module['instantiateWasm'](info, receiveInstance);\n          return exports;\n        } catch (e) {\n          err('Module.instantiateWasm callback failed with error: ' + e);\n          return false;\n        }\n      }\n\n      instantiateAsync();\n      return {}; // no exports yet; we'll fill them in later\n    } // Globals used by JS i64 conversions\n\n\n    var tempDouble;\n    var tempI64; // === Body ===\n\n    var ASM_CONSTS = []; // STATICTOP = STATIC_BASE + 2398640;\n\n    /* global initializers */\n\n    __ATINIT__.push({\n      func: function func() {\n        ___wasm_call_ctors();\n      }\n    });\n    /* no memory initializer */\n    // {{PRE_LIBRARY}}\n\n\n    function demangle(func) {\n      var __cxa_demangle_func = Module['___cxa_demangle'] || Module['__cxa_demangle'];\n\n      assert(__cxa_demangle_func);\n\n      try {\n        var s = func;\n        if (s.startsWith('__Z')) s = s.substr(1);\n        var len = lengthBytesUTF8(s) + 1;\n\n        var buf = _malloc(len);\n\n        stringToUTF8(s, buf, len);\n\n        var status = _malloc(4);\n\n        var ret = __cxa_demangle_func(buf, 0, 0, status);\n\n        if (HEAP32[status >> 2] === 0 && ret) {\n          return UTF8ToString(ret);\n        } // otherwise, libcxxabi failed\n\n      } catch (e) {// ignore problems here\n      } finally {\n        if (buf) _free(buf);\n        if (status) _free(status);\n        if (ret) _free(ret);\n      } // failure when using libcxxabi, don't demangle\n\n\n      return func;\n    }\n\n    function demangleAll(text) {\n      var regex = /\\b_Z[\\w\\d_]+/g;\n      return text.replace(regex, function (x) {\n        var y = demangle(x);\n        return x === y ? x : y + ' [' + x + ']';\n      });\n    }\n\n    function jsStackTrace() {\n      var err = new Error();\n\n      if (!err.stack) {\n        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n        // so try that as a special-case.\n        try {\n          throw new Error(0);\n        } catch (e) {\n          err = e;\n        }\n\n        if (!err.stack) {\n          return '(no stack trace available)';\n        }\n      }\n\n      return err.stack.toString();\n    }\n\n    function stackTrace() {\n      var js = jsStackTrace();\n      if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n      return demangleAll(js);\n    }\n\n    function ___lock() {}\n\n    function ___unlock() {}\n\n    function _abort() {\n      abort();\n    }\n\n    var _abs = Math_abs;\n\n    function _emscripten_get_heap_size() {\n      return HEAP8.length;\n    }\n\n    function _emscripten_get_sbrk_ptr() {\n      return 2399504;\n    }\n\n    var setjmpId = 0;\n\n    function _saveSetjmp(env, label, table, size) {\n      // Not particularly fast: slow table lookup of setjmpId to label. But setjmp\n      // prevents relooping anyhow, so slowness is to be expected. And typical case\n      // is 1 setjmp per invocation, or less.\n      env = env | 0;\n      label = label | 0;\n      table = table | 0;\n      size = size | 0;\n      var i = 0;\n      setjmpId = setjmpId + 1 | 0;\n      HEAP32[env >> 2] = setjmpId;\n\n      while ((i | 0) < (size | 0)) {\n        if ((HEAP32[table + (i << 3) >> 2] | 0) == 0) {\n          HEAP32[table + (i << 3) >> 2] = setjmpId;\n          HEAP32[table + ((i << 3) + 4) >> 2] = label; // prepare next slot\n\n          HEAP32[table + ((i << 3) + 8) >> 2] = 0;\n          setTempRet0(size | 0);\n          return table | 0;\n        }\n\n        i = i + 1 | 0;\n      } // grow the table\n\n\n      size = size * 2 | 0;\n      table = _realloc(table | 0, 8 * (size + 1 | 0) | 0) | 0;\n      table = _saveSetjmp(env | 0, label | 0, table | 0, size | 0) | 0;\n      setTempRet0(size | 0);\n      return table | 0;\n    }\n\n    function _testSetjmp(id, table, size) {\n      id = id | 0;\n      table = table | 0;\n      size = size | 0;\n      var i = 0,\n          curr = 0;\n\n      while ((i | 0) < (size | 0)) {\n        curr = HEAP32[table + (i << 3) >> 2] | 0;\n        if ((curr | 0) == 0) break;\n\n        if ((curr | 0) == (id | 0)) {\n          return HEAP32[table + ((i << 3) + 4) >> 2] | 0;\n        }\n\n        i = i + 1 | 0;\n      }\n\n      return 0;\n    }\n\n    function _longjmp(env, value) {\n      _setThrew(env, value || 1);\n\n      throw 'longjmp';\n    }\n\n    function _emscripten_longjmp(env, value) {\n      _longjmp(env, value);\n    }\n\n    function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src + num), dest);\n    }\n\n    function abortOnCannotGrowMemory(requestedSize) {\n      abort('Cannot enlarge memory arrays to size ' + requestedSize + ' bytes (OOM). Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + HEAP8.length + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n    }\n\n    function emscripten_realloc_buffer(size) {\n      try {\n        // round size grow request up to wasm page size (fixed 64KB per spec)\n        wasmMemory.grow(size - buffer.byteLength + 65535 >> 16); // .grow() takes a delta compared to the previous size\n\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        return 1\n        /*success*/\n        ;\n      } catch (e) {\n        console.error('emscripten_realloc_buffer: Attempted to grow heap from ' + buffer.byteLength + ' bytes to ' + size + ' bytes, but got error: ' + e);\n      }\n    }\n\n    function _emscripten_resize_heap(requestedSize) {\n      var oldSize = _emscripten_get_heap_size(); // With pthreads, races can happen (another thread might increase the size in between), so return a failure, and let the caller retry.\n\n\n      assert(requestedSize > oldSize);\n      var PAGE_MULTIPLE = 65536;\n      var LIMIT = 2147483648 - PAGE_MULTIPLE; // We can do one page short of 2GB as theoretical maximum.\n\n      if (requestedSize > LIMIT) {\n        err('Cannot enlarge memory, asked to go up to ' + requestedSize + ' bytes, but the limit is ' + LIMIT + ' bytes!');\n        return false;\n      }\n\n      var MIN_TOTAL_MEMORY = 16777216;\n      var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY); // So the loop below will not be infinite, and minimum asm.js memory size is 16MB.\n      // TODO: see realloc_buffer - for PTHREADS we may want to decrease these jumps\n\n      while (newSize < requestedSize) {\n        // Keep incrementing the heap size as long as it's less than what is requested.\n        if (newSize <= 536870912) {\n          newSize = alignUp(2 * newSize, PAGE_MULTIPLE); // Simple heuristic: double until 1GB...\n        } else {\n          // ..., but after that, add smaller increments towards 2GB, which we cannot reach\n          newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);\n        }\n\n        if (newSize === oldSize) {\n          warnOnce('Cannot ask for more memory since we reached the practical limit in browsers (which is just below 2GB), so the request would have failed. Requesting only ' + HEAP8.length);\n        }\n      }\n\n      var replacement = emscripten_realloc_buffer(newSize);\n\n      if (!replacement) {\n        err('Failed to grow the heap from ' + oldSize + ' bytes to ' + newSize + ' bytes, not enough memory!');\n        return false;\n      }\n\n      return true;\n    }\n\n    var PATH = {\n      splitPath: function splitPath(filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: function normalizeArray(parts, allowAboveRoot) {\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        } // if the path is allowed to go above the root, restore leading ..s\n\n\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift('..');\n          }\n        }\n\n        return parts;\n      },\n      normalize: function normalize(path) {\n        var isAbsolute = path.charAt(0) === '/',\n            trailingSlash = path.substr(-1) === '/'; // Normalize the path\n\n        path = PATH.normalizeArray(path.split('/').filter(function (p) {\n          return !!p;\n        }), !isAbsolute).join('/');\n\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n\n        if (path && trailingSlash) {\n          path += '/';\n        }\n\n        return (isAbsolute ? '/' : '') + path;\n      },\n      dirname: function dirname(path) {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n\n        if (!root && !dir) {\n          // No dirname whatsoever\n          return '.';\n        }\n\n        if (dir) {\n          // It has a dirname, strip trailing slash\n          dir = dir.substr(0, dir.length - 1);\n        }\n\n        return root + dir;\n      },\n      basename: function basename(path) {\n        // EMSCRIPTEN return '/'' for '/', not an empty string\n        if (path === '/') return '/';\n        var lastSlash = path.lastIndexOf('/');\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1);\n      },\n      extname: function extname(path) {\n        return PATH.splitPath(path)[3];\n      },\n      join: function join() {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join('/'));\n      },\n      join2: function join2(l, r) {\n        return PATH.normalize(l + '/' + r);\n      }\n    };\n    var SYSCALLS = {\n      buffers: [null, [], []],\n      printChar: function printChar(stream, curr) {\n        var buffer = SYSCALLS.buffers[stream];\n        assert(buffer);\n\n        if (curr === 0 || curr === 10) {\n          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n          buffer.length = 0;\n        } else {\n          buffer.push(curr);\n        }\n      },\n      varargs: 0,\n      get: function get(varargs) {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n        return ret;\n      },\n      getStr: function getStr() {\n        var ret = UTF8ToString(SYSCALLS.get());\n        return ret;\n      },\n      get64: function get64() {\n        var low = SYSCALLS.get(),\n            high = SYSCALLS.get();\n        if (low >= 0) assert(high === 0);else assert(high === -1);\n        return low;\n      },\n      getZero: function getZero() {\n        assert(SYSCALLS.get() === 0);\n      }\n    };\n\n    function _fd_close(fd) {\n      try {\n        abort('it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM');\n        return 0;\n      } catch (e) {\n        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n\n    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n      try {\n        abort('it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM');\n        return 0;\n      } catch (e) {\n        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n\n    function flush_NO_FILESYSTEM() {\n      // flush anything remaining in the buffers during shutdown\n      var fflush = Module[\"_fflush\"];\n      if (fflush) fflush(0);\n      var buffers = SYSCALLS.buffers;\n      if (buffers[1].length) SYSCALLS.printChar(1, 10);\n      if (buffers[2].length) SYSCALLS.printChar(2, 10);\n    }\n\n    function _fd_write(fd, iov, iovcnt, pnum) {\n      try {\n        // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\n        var num = 0;\n\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n\n          for (var j = 0; j < len; j++) {\n            SYSCALLS.printChar(fd, HEAPU8[ptr + j]);\n          }\n\n          num += len;\n        }\n\n        HEAP32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n\n    function _getTempRet0() {\n      return getTempRet0() | 0;\n    }\n\n    function _memcpy(dest, src, num) {\n      dest = dest | 0;\n      src = src | 0;\n      num = num | 0;\n      var ret = 0;\n      var aligned_dest_end = 0;\n      var block_aligned_dest_end = 0;\n      var dest_end = 0; // Test against a benchmarked cutoff limit for when HEAPU8.set() becomes faster to use.\n\n      if ((num | 0) >= 8192) {\n        _emscripten_memcpy_big(dest | 0, src | 0, num | 0) | 0;\n        return dest | 0;\n      }\n\n      ret = dest | 0;\n      dest_end = dest + num | 0;\n\n      if ((dest & 3) == (src & 3)) {\n        // The initial unaligned < 4-byte front.\n        while (dest & 3) {\n          if ((num | 0) == 0) return ret | 0;\n          HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;\n          dest = dest + 1 | 0;\n          src = src + 1 | 0;\n          num = num - 1 | 0;\n        }\n\n        aligned_dest_end = dest_end & -4 | 0;\n        block_aligned_dest_end = aligned_dest_end - 64 | 0;\n\n        while ((dest | 0) <= (block_aligned_dest_end | 0)) {\n          HEAP32[dest >> 2] = HEAP32[src >> 2] | 0;\n          HEAP32[dest + 4 >> 2] = HEAP32[src + 4 >> 2] | 0;\n          HEAP32[dest + 8 >> 2] = HEAP32[src + 8 >> 2] | 0;\n          HEAP32[dest + 12 >> 2] = HEAP32[src + 12 >> 2] | 0;\n          HEAP32[dest + 16 >> 2] = HEAP32[src + 16 >> 2] | 0;\n          HEAP32[dest + 20 >> 2] = HEAP32[src + 20 >> 2] | 0;\n          HEAP32[dest + 24 >> 2] = HEAP32[src + 24 >> 2] | 0;\n          HEAP32[dest + 28 >> 2] = HEAP32[src + 28 >> 2] | 0;\n          HEAP32[dest + 32 >> 2] = HEAP32[src + 32 >> 2] | 0;\n          HEAP32[dest + 36 >> 2] = HEAP32[src + 36 >> 2] | 0;\n          HEAP32[dest + 40 >> 2] = HEAP32[src + 40 >> 2] | 0;\n          HEAP32[dest + 44 >> 2] = HEAP32[src + 44 >> 2] | 0;\n          HEAP32[dest + 48 >> 2] = HEAP32[src + 48 >> 2] | 0;\n          HEAP32[dest + 52 >> 2] = HEAP32[src + 52 >> 2] | 0;\n          HEAP32[dest + 56 >> 2] = HEAP32[src + 56 >> 2] | 0;\n          HEAP32[dest + 60 >> 2] = HEAP32[src + 60 >> 2] | 0;\n          dest = dest + 64 | 0;\n          src = src + 64 | 0;\n        }\n\n        while ((dest | 0) < (aligned_dest_end | 0)) {\n          HEAP32[dest >> 2] = HEAP32[src >> 2] | 0;\n          dest = dest + 4 | 0;\n          src = src + 4 | 0;\n        }\n      } else {\n        // In the unaligned copy case, unroll a bit as well.\n        aligned_dest_end = dest_end - 4 | 0;\n\n        while ((dest | 0) < (aligned_dest_end | 0)) {\n          HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;\n          HEAP8[dest + 1 >> 0] = HEAP8[src + 1 >> 0] | 0;\n          HEAP8[dest + 2 >> 0] = HEAP8[src + 2 >> 0] | 0;\n          HEAP8[dest + 3 >> 0] = HEAP8[src + 3 >> 0] | 0;\n          dest = dest + 4 | 0;\n          src = src + 4 | 0;\n        }\n      } // The remaining unaligned < 4 byte tail.\n\n\n      while ((dest | 0) < (dest_end | 0)) {\n        HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;\n        dest = dest + 1 | 0;\n        src = src + 1 | 0;\n      }\n\n      return ret | 0;\n    }\n\n    function _memset(ptr, value, num) {\n      ptr = ptr | 0;\n      value = value | 0;\n      num = num | 0;\n      var end = 0,\n          aligned_end = 0,\n          block_aligned_end = 0,\n          value4 = 0;\n      end = ptr + num | 0;\n      value = value & 0xff;\n\n      if ((num | 0) >= 67\n      /* 64 bytes for an unrolled loop + 3 bytes for unaligned head*/\n      ) {\n          while ((ptr & 3) != 0) {\n            HEAP8[ptr >> 0] = value;\n            ptr = ptr + 1 | 0;\n          }\n\n          aligned_end = end & -4 | 0;\n          value4 = value | value << 8 | value << 16 | value << 24;\n          block_aligned_end = aligned_end - 64 | 0;\n\n          while ((ptr | 0) <= (block_aligned_end | 0)) {\n            HEAP32[ptr >> 2] = value4;\n            HEAP32[ptr + 4 >> 2] = value4;\n            HEAP32[ptr + 8 >> 2] = value4;\n            HEAP32[ptr + 12 >> 2] = value4;\n            HEAP32[ptr + 16 >> 2] = value4;\n            HEAP32[ptr + 20 >> 2] = value4;\n            HEAP32[ptr + 24 >> 2] = value4;\n            HEAP32[ptr + 28 >> 2] = value4;\n            HEAP32[ptr + 32 >> 2] = value4;\n            HEAP32[ptr + 36 >> 2] = value4;\n            HEAP32[ptr + 40 >> 2] = value4;\n            HEAP32[ptr + 44 >> 2] = value4;\n            HEAP32[ptr + 48 >> 2] = value4;\n            HEAP32[ptr + 52 >> 2] = value4;\n            HEAP32[ptr + 56 >> 2] = value4;\n            HEAP32[ptr + 60 >> 2] = value4;\n            ptr = ptr + 64 | 0;\n          }\n\n          while ((ptr | 0) < (aligned_end | 0)) {\n            HEAP32[ptr >> 2] = value4;\n            ptr = ptr + 4 | 0;\n          }\n        } // The remaining bytes.\n\n\n      while ((ptr | 0) < (end | 0)) {\n        HEAP8[ptr >> 0] = value;\n        ptr = ptr + 1 | 0;\n      }\n\n      return end - num | 0;\n    }\n\n    function _setTempRet0($i) {\n      setTempRet0($i | 0);\n    }\n\n    var ASSERTIONS = true; // Copyright 2017 The Emscripten Authors.  All rights reserved.\n    // Emscripten is available under two separate licenses, the MIT license and the\n    // University of Illinois/NCSA Open Source License.  Both these licenses can be\n    // found in the LICENSE file.\n\n    /** @type {function(string, boolean=, number=)} */\n\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n\n    function intArrayToString(array) {\n      var ret = [];\n\n      for (var i = 0; i < array.length; i++) {\n        var chr = array[i];\n\n        if (chr > 0xFF) {\n          if (ASSERTIONS) {\n            assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n          }\n\n          chr &= 0xFF;\n        }\n\n        ret.push(String.fromCharCode(chr));\n      }\n\n      return ret.join('');\n    } // ASM_LIBRARY EXTERN PRIMITIVES: Int8Array,Int32Array\n\n\n    var asmGlobalArg = {};\n    var asmLibraryArg = {\n      \"__lock\": ___lock,\n      \"__unlock\": ___unlock,\n      \"abort\": _abort,\n      \"abs\": _abs,\n      \"emscripten_get_sbrk_ptr\": _emscripten_get_sbrk_ptr,\n      \"emscripten_longjmp\": _emscripten_longjmp,\n      \"emscripten_memcpy_big\": _emscripten_memcpy_big,\n      \"emscripten_resize_heap\": _emscripten_resize_heap,\n      \"fd_close\": _fd_close,\n      \"fd_seek\": _fd_seek,\n      \"fd_write\": _fd_write,\n      \"getTempRet0\": _getTempRet0,\n      \"invoke_i\": invoke_i,\n      \"invoke_v\": invoke_v,\n      \"memory\": wasmMemory,\n      \"saveSetjmp\": _saveSetjmp,\n      \"setTempRet0\": _setTempRet0,\n      \"table\": wasmTable,\n      \"testSetjmp\": _testSetjmp\n    };\n    var asm = createWasm();\n    var real____wasm_call_ctors = asm[\"__wasm_call_ctors\"];\n\n    asm[\"__wasm_call_ctors\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real____wasm_call_ctors.apply(null, arguments);\n    };\n\n    var real__malloc = asm[\"malloc\"];\n\n    asm[\"malloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__malloc.apply(null, arguments);\n    };\n\n    var real__free = asm[\"free\"];\n\n    asm[\"free\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__free.apply(null, arguments);\n    };\n\n    var real__init = asm[\"init\"];\n\n    asm[\"init\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__init.apply(null, arguments);\n    };\n\n    var real__start = asm[\"start\"];\n\n    asm[\"start\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__start.apply(null, arguments);\n    };\n\n    var real__loop = asm[\"loop\"];\n\n    asm[\"loop\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__loop.apply(null, arguments);\n    };\n\n    var real__sound = asm[\"sound\"];\n\n    asm[\"sound\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__sound.apply(null, arguments);\n    };\n\n    var real__get_rom_buffer_ref = asm[\"get_rom_buffer_ref\"];\n\n    asm[\"get_rom_buffer_ref\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__get_rom_buffer_ref.apply(null, arguments);\n    };\n\n    var real__get_frame_buffer_ref = asm[\"get_frame_buffer_ref\"];\n\n    asm[\"get_frame_buffer_ref\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__get_frame_buffer_ref.apply(null, arguments);\n    };\n\n    var real__get_web_audio_l_ref = asm[\"get_web_audio_l_ref\"];\n\n    asm[\"get_web_audio_l_ref\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__get_web_audio_l_ref.apply(null, arguments);\n    };\n\n    var real__get_web_audio_r_ref = asm[\"get_web_audio_r_ref\"];\n\n    asm[\"get_web_audio_r_ref\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__get_web_audio_r_ref.apply(null, arguments);\n    };\n\n    var real__fflush = asm[\"fflush\"];\n\n    asm[\"fflush\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__fflush.apply(null, arguments);\n    };\n\n    var real____errno_location = asm[\"__errno_location\"];\n\n    asm[\"__errno_location\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real____errno_location.apply(null, arguments);\n    };\n\n    var real__setThrew = asm[\"setThrew\"];\n\n    asm[\"setThrew\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__setThrew.apply(null, arguments);\n    };\n\n    var real____cxa_demangle = asm[\"__cxa_demangle\"];\n\n    asm[\"__cxa_demangle\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real____cxa_demangle.apply(null, arguments);\n    };\n\n    var real__realloc = asm[\"realloc\"];\n\n    asm[\"realloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__realloc.apply(null, arguments);\n    };\n\n    var real_dynCall_i = asm[\"dynCall_i\"];\n\n    asm[\"dynCall_i\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_dynCall_i.apply(null, arguments);\n    };\n\n    var real_dynCall_v = asm[\"dynCall_v\"];\n\n    asm[\"dynCall_v\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_dynCall_v.apply(null, arguments);\n    };\n\n    var real_stackSave = asm[\"stackSave\"];\n\n    asm[\"stackSave\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_stackSave.apply(null, arguments);\n    };\n\n    var real_stackAlloc = asm[\"stackAlloc\"];\n\n    asm[\"stackAlloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_stackAlloc.apply(null, arguments);\n    };\n\n    var real_stackRestore = asm[\"stackRestore\"];\n\n    asm[\"stackRestore\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_stackRestore.apply(null, arguments);\n    };\n\n    var real___growWasmMemory = asm[\"__growWasmMemory\"];\n\n    asm[\"__growWasmMemory\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real___growWasmMemory.apply(null, arguments);\n    };\n\n    var real_dynCall_ii = asm[\"dynCall_ii\"];\n\n    asm[\"dynCall_ii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_dynCall_ii.apply(null, arguments);\n    };\n\n    var real_dynCall_vii = asm[\"dynCall_vii\"];\n\n    asm[\"dynCall_vii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_dynCall_vii.apply(null, arguments);\n    };\n\n    var real_dynCall_vi = asm[\"dynCall_vi\"];\n\n    asm[\"dynCall_vi\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_dynCall_vi.apply(null, arguments);\n    };\n\n    var real_dynCall_iii = asm[\"dynCall_iii\"];\n\n    asm[\"dynCall_iii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_dynCall_iii.apply(null, arguments);\n    };\n\n    var real_dynCall_viii = asm[\"dynCall_viii\"];\n\n    asm[\"dynCall_viii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_dynCall_viii.apply(null, arguments);\n    };\n\n    var real_dynCall_iidiiii = asm[\"dynCall_iidiiii\"];\n\n    asm[\"dynCall_iidiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_dynCall_iidiiii.apply(null, arguments);\n    };\n\n    var real_dynCall_iiii = asm[\"dynCall_iiii\"];\n\n    asm[\"dynCall_iiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_dynCall_iiii.apply(null, arguments);\n    };\n\n    var real_dynCall_jiji = asm[\"dynCall_jiji\"];\n\n    asm[\"dynCall_jiji\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_dynCall_jiji.apply(null, arguments);\n    };\n\n    var real_dynCall_viiiiii = asm[\"dynCall_viiiiii\"];\n\n    asm[\"dynCall_viiiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_dynCall_viiiiii.apply(null, arguments);\n    };\n\n    var real_dynCall_viiiii = asm[\"dynCall_viiiii\"];\n\n    asm[\"dynCall_viiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_dynCall_viiiii.apply(null, arguments);\n    };\n\n    var real_dynCall_viiii = asm[\"dynCall_viiii\"];\n\n    asm[\"dynCall_viiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_dynCall_viiii.apply(null, arguments);\n    };\n\n    Module[\"asm\"] = asm;\n\n    var ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"__wasm_call_ctors\"].apply(null, arguments);\n    };\n\n    var _malloc = Module[\"_malloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"malloc\"].apply(null, arguments);\n    };\n\n    var _free = Module[\"_free\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"free\"].apply(null, arguments);\n    };\n\n    var _init = Module[\"_init\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"init\"].apply(null, arguments);\n    };\n\n    var _start = Module[\"_start\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"start\"].apply(null, arguments);\n    };\n\n    var _loop = Module[\"_loop\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"loop\"].apply(null, arguments);\n    };\n\n    var _sound = Module[\"_sound\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"sound\"].apply(null, arguments);\n    };\n\n    var _get_rom_buffer_ref = Module[\"_get_rom_buffer_ref\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"get_rom_buffer_ref\"].apply(null, arguments);\n    };\n\n    var _get_frame_buffer_ref = Module[\"_get_frame_buffer_ref\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"get_frame_buffer_ref\"].apply(null, arguments);\n    };\n\n    var _get_web_audio_l_ref = Module[\"_get_web_audio_l_ref\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"get_web_audio_l_ref\"].apply(null, arguments);\n    };\n\n    var _get_web_audio_r_ref = Module[\"_get_web_audio_r_ref\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"get_web_audio_r_ref\"].apply(null, arguments);\n    };\n\n    var _fflush = Module[\"_fflush\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"fflush\"].apply(null, arguments);\n    };\n\n    var ___errno_location = Module[\"___errno_location\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"__errno_location\"].apply(null, arguments);\n    };\n\n    var _setThrew = Module[\"_setThrew\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"setThrew\"].apply(null, arguments);\n    };\n\n    var ___cxa_demangle = Module[\"___cxa_demangle\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"__cxa_demangle\"].apply(null, arguments);\n    };\n\n    var _realloc = Module[\"_realloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"realloc\"].apply(null, arguments);\n    };\n\n    var dynCall_i = Module[\"dynCall_i\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_i\"].apply(null, arguments);\n    };\n\n    var dynCall_v = Module[\"dynCall_v\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_v\"].apply(null, arguments);\n    };\n\n    var stackSave = Module[\"stackSave\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"stackSave\"].apply(null, arguments);\n    };\n\n    var stackAlloc = Module[\"stackAlloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments);\n    };\n\n    var stackRestore = Module[\"stackRestore\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"stackRestore\"].apply(null, arguments);\n    };\n\n    var __growWasmMemory = Module[\"__growWasmMemory\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"__growWasmMemory\"].apply(null, arguments);\n    };\n\n    var dynCall_ii = Module[\"dynCall_ii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments);\n    };\n\n    var dynCall_vii = Module[\"dynCall_vii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_vii\"].apply(null, arguments);\n    };\n\n    var dynCall_vi = Module[\"dynCall_vi\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_vi\"].apply(null, arguments);\n    };\n\n    var dynCall_iii = Module[\"dynCall_iii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iii\"].apply(null, arguments);\n    };\n\n    var dynCall_viii = Module[\"dynCall_viii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viii\"].apply(null, arguments);\n    };\n\n    var dynCall_iidiiii = Module[\"dynCall_iidiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iidiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_iiii = Module[\"dynCall_iiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments);\n    };\n\n    var dynCall_jiji = Module[\"dynCall_jiji\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_jiji\"].apply(null, arguments);\n    };\n\n    var dynCall_viiiiii = Module[\"dynCall_viiiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viiiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_viiiii = Module[\"dynCall_viiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_viiii = Module[\"dynCall_viiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viiii\"].apply(null, arguments);\n    };\n\n    function invoke_v(index) {\n      var sp = stackSave();\n\n      try {\n        dynCall_v(index);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0 && e !== 'longjmp') throw e;\n\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_i(index) {\n      var sp = stackSave();\n\n      try {\n        return dynCall_i(index);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0 && e !== 'longjmp') throw e;\n\n        _setThrew(1, 0);\n      }\n    } // === Auto-generated postamble setup entry stuff ===\n\n\n    Module['asm'] = asm;\n    if (!Object.getOwnPropertyDescriptor(Module, \"intArrayFromString\")) Module[\"intArrayFromString\"] = function () {\n      abort(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"intArrayToString\")) Module[\"intArrayToString\"] = function () {\n      abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"ccall\")) Module[\"ccall\"] = function () {\n      abort(\"'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"cwrap\")) Module[\"cwrap\"] = function () {\n      abort(\"'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"setValue\")) Module[\"setValue\"] = function () {\n      abort(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getValue\")) Module[\"getValue\"] = function () {\n      abort(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"allocate\")) Module[\"allocate\"] = function () {\n      abort(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getMemory\")) Module[\"getMemory\"] = function () {\n      abort(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"AsciiToString\")) Module[\"AsciiToString\"] = function () {\n      abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stringToAscii\")) Module[\"stringToAscii\"] = function () {\n      abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"UTF8ArrayToString\")) Module[\"UTF8ArrayToString\"] = function () {\n      abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"UTF8ToString\")) Module[\"UTF8ToString\"] = function () {\n      abort(\"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF8Array\")) Module[\"stringToUTF8Array\"] = function () {\n      abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF8\")) Module[\"stringToUTF8\"] = function () {\n      abort(\"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF8\")) Module[\"lengthBytesUTF8\"] = function () {\n      abort(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"UTF16ToString\")) Module[\"UTF16ToString\"] = function () {\n      abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF16\")) Module[\"stringToUTF16\"] = function () {\n      abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF16\")) Module[\"lengthBytesUTF16\"] = function () {\n      abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"UTF32ToString\")) Module[\"UTF32ToString\"] = function () {\n      abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF32\")) Module[\"stringToUTF32\"] = function () {\n      abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF32\")) Module[\"lengthBytesUTF32\"] = function () {\n      abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"allocateUTF8\")) Module[\"allocateUTF8\"] = function () {\n      abort(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = function () {\n      abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"addOnPreRun\")) Module[\"addOnPreRun\"] = function () {\n      abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"addOnInit\")) Module[\"addOnInit\"] = function () {\n      abort(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"addOnPreMain\")) Module[\"addOnPreMain\"] = function () {\n      abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"addOnExit\")) Module[\"addOnExit\"] = function () {\n      abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"addOnPostRun\")) Module[\"addOnPostRun\"] = function () {\n      abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"writeStringToMemory\")) Module[\"writeStringToMemory\"] = function () {\n      abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"writeArrayToMemory\")) Module[\"writeArrayToMemory\"] = function () {\n      abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"writeAsciiToMemory\")) Module[\"writeAsciiToMemory\"] = function () {\n      abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"addRunDependency\")) Module[\"addRunDependency\"] = function () {\n      abort(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"removeRunDependency\")) Module[\"removeRunDependency\"] = function () {\n      abort(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"ENV\")) Module[\"ENV\"] = function () {\n      abort(\"'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"FS\")) Module[\"FS\"] = function () {\n      abort(\"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"FS_createFolder\")) Module[\"FS_createFolder\"] = function () {\n      abort(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"FS_createPath\")) Module[\"FS_createPath\"] = function () {\n      abort(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"FS_createDataFile\")) Module[\"FS_createDataFile\"] = function () {\n      abort(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"FS_createPreloadedFile\")) Module[\"FS_createPreloadedFile\"] = function () {\n      abort(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"FS_createLazyFile\")) Module[\"FS_createLazyFile\"] = function () {\n      abort(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"FS_createLink\")) Module[\"FS_createLink\"] = function () {\n      abort(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"FS_createDevice\")) Module[\"FS_createDevice\"] = function () {\n      abort(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"FS_unlink\")) Module[\"FS_unlink\"] = function () {\n      abort(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"GL\")) Module[\"GL\"] = function () {\n      abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"dynamicAlloc\")) Module[\"dynamicAlloc\"] = function () {\n      abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"loadDynamicLibrary\")) Module[\"loadDynamicLibrary\"] = function () {\n      abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"loadWebAssemblyModule\")) Module[\"loadWebAssemblyModule\"] = function () {\n      abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getLEB\")) Module[\"getLEB\"] = function () {\n      abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getFunctionTables\")) Module[\"getFunctionTables\"] = function () {\n      abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"alignFunctionTables\")) Module[\"alignFunctionTables\"] = function () {\n      abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"registerFunctions\")) Module[\"registerFunctions\"] = function () {\n      abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"addFunction\")) Module[\"addFunction\"] = function () {\n      abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"removeFunction\")) Module[\"removeFunction\"] = function () {\n      abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getFuncWrapper\")) Module[\"getFuncWrapper\"] = function () {\n      abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"prettyPrint\")) Module[\"prettyPrint\"] = function () {\n      abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"makeBigInt\")) Module[\"makeBigInt\"] = function () {\n      abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"dynCall\")) Module[\"dynCall\"] = function () {\n      abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getCompilerSetting\")) Module[\"getCompilerSetting\"] = function () {\n      abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stackSave\")) Module[\"stackSave\"] = function () {\n      abort(\"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stackRestore\")) Module[\"stackRestore\"] = function () {\n      abort(\"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"stackAlloc\")) Module[\"stackAlloc\"] = function () {\n      abort(\"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"establishStackSpace\")) Module[\"establishStackSpace\"] = function () {\n      abort(\"'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"print\")) Module[\"print\"] = function () {\n      abort(\"'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"printErr\")) Module[\"printErr\"] = function () {\n      abort(\"'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"getTempRet0\")) Module[\"getTempRet0\"] = function () {\n      abort(\"'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"setTempRet0\")) Module[\"setTempRet0\"] = function () {\n      abort(\"'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"callMain\")) Module[\"callMain\"] = function () {\n      abort(\"'callMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"abort\")) Module[\"abort\"] = function () {\n      abort(\"'abort' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"Pointer_stringify\")) Module[\"Pointer_stringify\"] = function () {\n      abort(\"'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Object.getOwnPropertyDescriptor(Module, \"warnOnce\")) Module[\"warnOnce\"] = function () {\n      abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    Module[\"writeStackCookie\"] = writeStackCookie;\n    Module[\"checkStackCookie\"] = checkStackCookie;\n    Module[\"abortStackOverflow\"] = abortStackOverflow;\n    if (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_NORMAL\")) Object.defineProperty(Module, \"ALLOC_NORMAL\", {\n      configurable: true,\n      get: function get() {\n        abort(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_STACK\")) Object.defineProperty(Module, \"ALLOC_STACK\", {\n      configurable: true,\n      get: function get() {\n        abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_DYNAMIC\")) Object.defineProperty(Module, \"ALLOC_DYNAMIC\", {\n      configurable: true,\n      get: function get() {\n        abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_NONE\")) Object.defineProperty(Module, \"ALLOC_NONE\", {\n      configurable: true,\n      get: function get() {\n        abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Object.getOwnPropertyDescriptor(Module, \"calledRun\")) Object.defineProperty(Module, \"calledRun\", {\n      configurable: true,\n      get: function get() {\n        abort(\"'calledRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n      }\n    });\n    var calledRun; // Modularize mode returns a function, which can be called to\n    // create instances. The instances provide a then() method,\n    // must like a Promise, that receives a callback. The callback\n    // is called when the module is ready to run, with the module\n    // as a parameter. (Like a Promise, it also returns the module\n    // so you can use the output of .then(..)).\n\n    Module['then'] = function (func) {\n      // We may already be ready to run code at this time. if\n      // so, just queue a call to the callback.\n      if (calledRun) {\n        func(Module);\n      } else {\n        // we are not ready to call then() yet. we must call it\n        // at the same time we would call onRuntimeInitialized.\n        var old = Module['onRuntimeInitialized'];\n\n        Module['onRuntimeInitialized'] = function () {\n          if (old) old();\n          func(Module);\n        };\n      }\n\n      return Module;\n    };\n    /**\n     * @constructor\n     * @this {ExitStatus}\n     */\n\n\n    function ExitStatus(status) {\n      this.name = \"ExitStatus\";\n      this.message = \"Program terminated with exit(\" + status + \")\";\n      this.status = status;\n    }\n\n    var calledMain = false;\n\n    dependenciesFulfilled = function runCaller() {\n      // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n    };\n    /** @type {function(Array=)} */\n\n\n    function run(args) {\n      args = args || arguments_;\n\n      if (runDependencies > 0) {\n        return;\n      }\n\n      writeStackCookie();\n      preRun();\n      if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n\n      function doRun() {\n        // run may have just been called through dependencies being fulfilled just in this very frame,\n        // or while the async setStatus time below was happening\n        if (calledRun) return;\n        calledRun = true;\n        if (ABORT) return;\n        initRuntime();\n        preMain();\n        if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n        assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n        postRun();\n      }\n\n      if (Module['setStatus']) {\n        Module['setStatus']('Running...');\n        setTimeout(function () {\n          setTimeout(function () {\n            Module['setStatus']('');\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n\n      checkStackCookie();\n    }\n\n    Module['run'] = run;\n\n    function checkUnflushedContent() {\n      // Compiler settings do not allow exiting the runtime, so flushing\n      // the streams is not possible. but in ASSERTIONS mode we check\n      // if there was something to flush, and if so tell the user they\n      // should request that the runtime be exitable.\n      // Normally we would not even include flush() at all, but in ASSERTIONS\n      // builds we do so just for this check, and here we see if there is any\n      // content to flush, that is, we check if there would have been\n      // something a non-ASSERTIONS build would have not seen.\n      // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n      // mode (which has its own special function for this; otherwise, all\n      // the code is inside libc)\n      var print = out;\n      var printErr = err;\n      var has = false;\n\n      out = err = function err(x) {\n        has = true;\n      };\n\n      try {\n        // it doesn't matter if it fails\n        var flush = flush_NO_FILESYSTEM;\n        if (flush) flush(0);\n      } catch (e) {}\n\n      out = print;\n      err = printErr;\n\n      if (has) {\n        warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');\n        warnOnce('(this may also be due to not including full filesystem support - try building with -s FORCE_FILESYSTEM=1)');\n      }\n    }\n\n    function exit(status, implicit) {\n      checkUnflushedContent(); // if this is just main exit-ing implicitly, and the status is 0, then we\n      // don't need to do anything here and can just leave. if the status is\n      // non-zero, though, then we need to report it.\n      // (we may have warned about this earlier, if a situation justifies doing so)\n\n      if (implicit && noExitRuntime && status === 0) {\n        return;\n      }\n\n      if (noExitRuntime) {\n        // if exit() was called, we may warn the user if the runtime isn't actually being shut down\n        if (!implicit) {\n          err('program exited (with status: ' + status + '), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)');\n        }\n      } else {\n        ABORT = true;\n        EXITSTATUS = status;\n        exitRuntime();\n        if (Module['onExit']) Module['onExit'](status);\n      }\n\n      quit_(status, new ExitStatus(status));\n    }\n\n    if (Module['preInit']) {\n      if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n\n      while (Module['preInit'].length > 0) {\n        Module['preInit'].pop()();\n      }\n    }\n\n    noExitRuntime = true;\n    run(); // {{MODULE_ADDITIONS}}\n\n    return Module;\n  };\n}();\n\nif (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = Module;else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  return Module;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/process/browser.js */ \"./node_modules/process/browser.js\"), \"/\", __webpack_require__(/*! ./../../../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./src/main/js/genplus.js?");

/***/ }),

/***/ "./src/main/js/genplus.wasm":
/*!**********************************!*\
  !*** ./src/main/js/genplus.wasm ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"genplus.wasm\";\n\n//# sourceURL=webpack:///./src/main/js/genplus.wasm?");

/***/ }),

/***/ "./src/main/js/index.js":
/*!******************************!*\
  !*** ./src/main/js/index.js ***!
  \******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _genplus_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./genplus.js */ \"./src/main/js/genplus.js\");\n/* harmony import */ var _genplus_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_genplus_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _genplus_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./genplus.wasm */ \"./src/main/js/genplus.wasm\");\n/* harmony import */ var _genplus_wasm__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_genplus_wasm__WEBPACK_IMPORTED_MODULE_1__);\n\n\nvar ROM_PATH = './roms/sonic2.bin';\nvar CANVAS_WIDTH = 640;\nvar CANVAS_HEIGHT = 480;\nvar SOUND_FREQUENCY = 44100; // emulator\n\nvar gens;\nvar romdata; // canvas member\n\nvar canvas;\nvar canvasContext;\nvar canvasImageData; // fps control\n\nvar FPS = 60;\nvar INTERVAL = 1000 / FPS;\nvar now;\nvar then;\nvar delta; // audio member\n\nvar audioContext; // canvas setting\n\n(function () {\n  canvas = document.getElementById('screen');\n  canvas.setAttribute('width', CANVAS_WIDTH);\n  canvas.setAttribute('height', CANVAS_HEIGHT);\n  var pixelRatio = window.devicePixelRatio ? window.devicePixelRatio : 1;\n\n  if (pixelRatio > 1 && window.screen.width < CANVAS_WIDTH) {\n    canvas.style.width = CANVAS_WIDTH + \"px\";\n    canvas.style.heigth = CANVAS_HEIGHT + \"px\";\n  }\n\n  canvasContext = canvas.getContext('2d');\n  canvasImageData = canvasContext.createImageData(CANVAS_WIDTH, CANVAS_HEIGHT); // hit any key for audio context\n\n  canvasContext.font = \"48px monospace\";\n  canvasContext.fillStyle = \"#fff\";\n  canvasContext.fillText(\"HIT ANY KEY!\", 80, 100);\n})();\n\n_genplus_js__WEBPACK_IMPORTED_MODULE_0___default()().then(function (module) {\n  gens = module; // memory allocate\n\n  gens._init();\n\n  console.log(gens); // load rom\n\n  fetch(ROM_PATH).then(function (response) {\n    return response.arrayBuffer();\n  }).then(function (bytes) {\n    // create buffer from wasm\n    romdata = new Uint8Array(gens.HEAPU8.buffer, gens._get_rom_buffer_ref(), bytes.byteLength);\n    romdata.set(new Uint8Array(bytes));\n    canvas.addEventListener('click', start, false);\n  });\n});\n\nvar start = function start() {\n  canvas.removeEventListener('click', start, false); // emulator start\n\n  gens._start(); // audio init\n\n\n  audioContext = new AudioContext(); // game loop\n\n  then = Date.now();\n  loop();\n};\n\nvar loop = function loop() {\n  requestAnimationFrame(loop);\n  now = Date.now();\n  delta = now - then;\n\n  if (delta > INTERVAL) {\n    // update\n    gens._loop();\n\n    then = now - delta % INTERVAL; // sound\n\n    var sampleSize = gens._sound();\n\n    var audioBuffer = audioContext.createBuffer(2, sampleSize, SOUND_FREQUENCY);\n    var audio_l = new Float32Array(gens.HEAPF32.buffer, gens._get_web_audio_l_ref(), sampleSize);\n    var audio_r = new Float32Array(gens.HEAPF32.buffer, gens._get_web_audio_r_ref(), sampleSize);\n    audioBuffer.getChannelData(0).set(audio_l);\n    audioBuffer.getChannelData(1).set(audio_r);\n    var source = audioContext.createBufferSource();\n    source.buffer = audioBuffer;\n    source.connect(audioContext.destination);\n    source.start(0); // draw\n\n    var vram = new Uint8ClampedArray(gens.HEAPU8.buffer, gens._get_frame_buffer_ref(), CANVAS_WIDTH * CANVAS_HEIGHT * 4);\n    canvasImageData.data.set(vram);\n    canvasContext.putImageData(canvasImageData, 0, 0);\n  }\n};\n\n//# sourceURL=webpack:///./src/main/js/index.js?");

/***/ }),

/***/ "fs":
/*!************************!*\
  !*** external "empty" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = empty;\n\n//# sourceURL=webpack:///external_%22empty%22?");

/***/ })

/******/ });